<div class="message">
SQL is a well-adopted interface especially for those non-computer major people. Several projects including Hive, Drill, Phoenix and Spark have already invested significantly in their SQL layers. Here we implement a Storm-based query language system for real time stream data analysis. 
</div>
<p><!-- more --></p>

<h2 id="relevant-research">Relevant Research</h2>
<p>For Apache storm <a href="http://storm.apache.org/2017/03/29/storm110-released.html">1.1.0</a> or later version, it has already provided Streaming SQL. In VLDB-2016, <a href="http://data.epfl.ch/">EPFL DATA Lab</a> implemented a streaming online query processing / analytics engine based on Apache Storm named <a href="https://github.com/epfldata/squall"><code class="highlighter-rouge">squall</code></a>.</p>

<h2 id="system-architecture">System Architecture</h2>
<p>Here we just implement a similar <code class="highlighter-rouge">demo</code> system which supports real time stream data analysis. The whole architecture is shown below:</p>

<p><img src="/assets/blog-img/2017_06_05_architecture.png" alt="image" title="System Architecture" /></p>

<p>As we can see from the above picture, when the user type a SQL-formatted query clause, the query sequence will be translated into a <code class="highlighter-rouge">query plan</code> which presents in the shape of a directed acyclic graph. The DAG-formatted query plan is optimized.
Then it will be mapped into a Storm topology dynamically. Then the topology will be submitted to Storm cluster for running.</p>

<h2 id="key-compoments">Key Compoments</h2>

<p>Here, the SQL parser is implemented by taking use of <a href="https://github.com/antlr/antlr4">ANTLR</a>. <a href="http://www.antlr.org/">ANTLR(ANother Tool for Language Recognition)</a> is a powerful parser generator. Here we design the following BNF-formatted grammar for SQL:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">grammar</span> <span class="n">sql</span><span class="p">;</span>

<span class="p">@</span><span class="n">header</span> <span class="p">{</span>
<span class="k">package</span> <span class="n">storm_sql</span><span class="p">.</span><span class="n">parser</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">root</span>
    <span class="p">:</span> <span class="s1">'select'</span> <span class="n">select_list</span>
    <span class="s1">'from'</span> <span class="n">table_sources</span>
    <span class="p">(</span><span class="s1">'where'</span> <span class="n">search_condition</span><span class="p">)?</span>
    <span class="p">(</span><span class="s1">'group'</span> <span class="s1">'by'</span> <span class="n">group_by_item</span> <span class="p">(</span><span class="s1">','</span> <span class="n">group_by_item</span><span class="p">)*)?</span>
    <span class="p">(</span><span class="s1">'having'</span> <span class="n">search_condition</span><span class="p">)?</span>
    <span class="p">(</span><span class="s1">'within'</span> <span class="n">within_time</span><span class="p">)?</span>
    <span class="p">;</span>


<span class="n">select_list</span>
    <span class="p">:</span> <span class="n">select_list_elem</span> <span class="p">(</span><span class="s1">','</span> <span class="n">select_list_elem</span><span class="p">)*</span>	<span class="p">#</span><span class="n">printSelectList</span>
    <span class="p">;</span>

<span class="n">select_list_elem</span>
    <span class="p">:</span> <span class="p">/*(</span><span class="n">table_name</span><span class="p">=</span><span class="n">ID</span> <span class="s1">'.'</span> <span class="n">column_name</span><span class="p">=</span><span class="n">ID</span><span class="p">)*/</span>
    <span class="n">expression</span>					<span class="p">#</span><span class="n">printSelectListElem</span>
    <span class="p">|</span> <span class="n">aggregate_function</span><span class="s1">'('</span> <span class="n">expression</span> <span class="s1">')'</span>	<span class="p">#</span><span class="n">selectAggregateFunction</span>
    <span class="p">;</span>

<span class="n">ID</span>
    <span class="p">:</span> <span class="p">[</span><span class="n">a</span><span class="p">-</span><span class="n">zA</span><span class="p">-</span><span class="n">Z_</span><span class="p">][</span><span class="n">a</span><span class="p">-</span><span class="n">zA</span><span class="p">-</span><span class="n">Z_0</span><span class="p">-</span><span class="m">9</span><span class="p">]*</span>
    <span class="p">;</span>

<span class="n">table_sources</span>
    <span class="p">:</span> <span class="n">table_source</span> <span class="p">(</span><span class="s1">','</span> <span class="n">table_source</span><span class="p">)*</span>		<span class="p">#</span><span class="n">tableSources</span>
    <span class="p">;</span>

<span class="n">table_source</span>
    <span class="p">:</span> <span class="n">ID</span>					<span class="p">#</span><span class="n">tableSource</span>
    <span class="p">;</span>

<span class="n">expression</span>
    <span class="p">:</span> <span class="n">aggregate_function</span>			<span class="p">#</span><span class="n">exprAggrFunc</span>
    <span class="p">|</span> <span class="p">(</span><span class="n">table_name</span> <span class="s1">'.'</span> <span class="n">column_name</span><span class="p">)</span>		<span class="p">#</span><span class="n">expr</span>
    <span class="p">|</span> <span class="n">NUM</span>					<span class="p">#</span><span class="n">num</span>
    <span class="p">|</span> <span class="n">ID</span>                    <span class="p">#</span><span class="n">id</span>
    <span class="p">;</span>

<span class="n">NUM</span>
    <span class="p">:</span> <span class="s1">'-'</span><span class="p">[</span><span class="m">1</span><span class="p">-</span><span class="m">9</span><span class="p">][</span><span class="m">0</span><span class="p">-</span><span class="m">9</span><span class="p">]*</span>
    <span class="p">|</span> <span class="s1">'0'</span>
    <span class="p">|</span> <span class="p">[</span><span class="m">1</span><span class="p">-</span><span class="m">9</span><span class="p">][</span><span class="m">0</span><span class="p">-</span><span class="m">9</span><span class="p">]*</span>
    <span class="p">;</span>

<span class="n">table_name</span>
    <span class="p">:</span> <span class="n">ID</span>					<span class="p">#</span><span class="n">tableName</span>
    <span class="p">;</span>

<span class="n">column_name</span>
    <span class="p">:</span> <span class="n">ID</span>					<span class="p">#</span><span class="n">columnName</span>
    <span class="p">;</span>

<span class="n">aggregate_function</span>
    <span class="p">:</span> <span class="s1">'avg'</span> <span class="p">|</span> <span class="s1">'max'</span> <span class="p">|</span> <span class="s1">'min'</span> <span class="p">|</span> <span class="s1">'sum'</span><span class="p">|</span> <span class="s1">'count'</span>
    <span class="p">;</span>

<span class="n">search_condition</span>
    <span class="p">:</span> <span class="n">search_condition_and</span> <span class="p">(</span><span class="s1">'and'</span> <span class="n">search_condition_and</span><span class="p">)*</span>	<span class="p">#</span><span class="n">printSearchCondition</span>
    <span class="p">;</span>

<span class="n">search_condition_and</span>
    <span class="p">:</span> <span class="n">expression</span> <span class="n">comparison_operator</span> <span class="n">expression</span>			<span class="p">#</span><span class="n">printSearchConditionAnd</span>
    <span class="p">//|</span> <span class="s1">'('</span> <span class="n">search_condition</span> <span class="s1">')'</span>
    <span class="p">;</span>

<span class="n">comparison_operator</span>
    <span class="p">:</span> <span class="s1">'='</span> <span class="p">|</span> <span class="s1">'&gt;'</span> <span class="p">|</span> <span class="s1">'&lt;'</span> <span class="p">|</span> <span class="s1">'&lt;='</span> <span class="p">|</span> <span class="s1">'&gt;='</span> <span class="p">|</span> <span class="s1">'!='</span>
    <span class="p">;</span>

<span class="n">group_by_item</span>
    <span class="p">:</span> <span class="n">expression</span>						<span class="p">#</span><span class="n">groupByItem</span>
    <span class="p">;</span>

<span class="n">within_time</span>
    <span class="p">:</span> <span class="p">(</span><span class="n">NUM</span><span class="p">)</span>							<span class="p">#</span><span class="n">withinTime</span>
    <span class="p">;</span>

<span class="n">WS</span>  <span class="p">:</span> <span class="p">[</span> <span class="p">\</span><span class="n">t</span><span class="p">\</span><span class="n">r</span><span class="p">\</span><span class="n">n</span><span class="p">]+</span> <span class="p">-&gt;</span> <span class="n">skip</span> <span class="p">;</span> <span class="p">//</span> <span class="n">Define</span> <span class="n">whitespace</span> <span class="n">rule</span><span class="p">,</span> <span class="n">toss</span> <span class="n">it</span> <span class="n">out</span>

</code></pre></div></div>

<p>By ANTLR <code class="highlighter-rouge">-visitor</code> tool, we can easily visit the AST through <code class="highlighter-rouge">visitor design pattern</code>. We store the necessary info of the sql sequence to build the DAG-formatted query plan. Here we use <a href="https://github.com/jgrapht/jgrapht"><code class="highlighter-rouge">JGraphT</code></a> to traverse the DAG, since it provides various interfaces for handling the DAG. We can eliminate the trouble of reinventing the wheel.
To automatically generate Storm topology from the DAG-formatted query plan, we need to mark the father and child of each node in the DAG. In the DAG, the source tables are Storm spouts in Storm topology. Similarly, the operators of the DAG is storm bolts in Storm topology, so you need to implement these bolts ahead of schedule. Notice, join and group-by operators are time window based, in Storm, you can simply extend <code class="highlighter-rouge">BaseWindowedBolt</code> to implement the concepts of time window. Of course, you also have to connect to data sources to create Storm spouts to get the stream data. Here we simply create two spouts named <code class="highlighter-rouge">student and tc</code> to simulate the stream source data.</p>

<p>The key features of the system include:</p>
<ul>
  <li>the SQL parser is based on <code class="highlighter-rouge">ANTLR</code>, it is universal for users’ typing input;</li>
  <li>the DAG-formatted query plan is based on <code class="highlighter-rouge">JGraphT</code>, you can access any vertex as you want;</li>
  <li>the Storm topology is generated from the query plan <code class="highlighter-rouge">dynamically</code>, that is to say the whole system is not limited to a specific application or a specific stream data.</li>
</ul>

<p>Of course, the demo system is nothing but a demo, there is a lot to be improved. However, you can follow the whole architecture to develop your own interface.</p>

<p>For more details about the src, see <a href="https://github.com/lijiansong/distribution/tree/master/storm/storm-sql/storm-sql/course-project">here…</a></p>

<p>Any questions or suggestions, feel free to open an issue @<a href="https://github.com/lijiansong/distribution/issues">here</a> or e-mail me to <em>lijiansong@ict.ac.cn</em>.</p>
